require 'pdf-reader'
require 'mini_magick'
require 'fileutils'
require 'base64'

class PdfToMarkdown
  attr_reader :page_count, :total_text_blocks, :metadata, :images_extracted

  def initialize(file_path, options = {})
    @file_path = file_path
    @options = options
    @page_count = 0
    @total_text_blocks = 0
    @images_extracted = 0
    @metadata = {}
    load_pdf
  end

  def convert_to_markdown(output_file)
    markdown_content = []

    # Add file header
    markdown_content << '# PDF to Markdown Conversion'
    markdown_content << ''
    markdown_content << "**Source File:** `#{File.basename(@file_path)}`"
    markdown_content << "**Converted:** #{Time.now.strftime('%Y-%m-%d %H:%M:%S')}"
    markdown_content << ''

    # Add metadata if available
    if @metadata && !@metadata.empty?
      markdown_content << '## Document Metadata'
      markdown_content << ''
      @metadata.each do |key, value|
        next if value.nil? || value.to_s.strip.empty?

        formatted_key = key.to_s.split('_').map(&:capitalize).join(' ')
        markdown_content << "- **#{formatted_key}:** #{value}"
      end
      markdown_content << ''
    end

    markdown_content << '---'
    markdown_content << ''

    # Process each page
    if @options[:page]
      # Convert specific page
      page_num = @options[:page].to_i
      unless page_num > 0 && page_num <= @pdf.pages.length
        raise "Invalid page number: #{page_num}. PDF has #{@pdf.pages.length} pages."
      end

      page_content = extract_page_content(page_num)
      markdown_content.concat(page_content)

    else
      # Convert all pages
      @pdf.pages.each_with_index do |_page, index|
        page_num = index + 1

        markdown_content << "## Page #{page_num}"
        markdown_content << ''

        page_content = extract_page_content(page_num)

        if page_content.empty?
          markdown_content << '*This page is empty or contains only images.*'
          markdown_content << ''
        else
          markdown_content.concat(page_content)
        end

        markdown_content << ''
        markdown_content << '---'
        markdown_content << ''

        puts "  ✓ Processed page: #{page_num}/#{@pdf.pages.length}".green if @options[:verbose]
      end
    end

    # Add footer
    markdown_content << ''
    markdown_content << '---'
    markdown_content << ''
    markdown_content << '*Generated by pdf2md tool by SmallPE Agents at SmallPE.com*'

    # Add statistics if verbose
    if @options[:verbose]
      markdown_content << ''
      markdown_content << '<!-- Conversion Statistics'
      markdown_content << "Pages processed: #{@page_count}"
      markdown_content << "Text blocks extracted: #{@total_text_blocks}"
      markdown_content << "Images extracted: #{@images_extracted}" if @options[:extract_images]
      markdown_content << '-->'
    end

    # Write to file
    File.write(output_file, markdown_content.join("\n"))
  end

  def file_info
    {
      file: @file_path,
      pages: @pdf.pages.length,
      metadata: @metadata,
      pdf_version: @pdf.pdf_version,
      producer: @pdf.info[:Producer],
      creator: @pdf.info[:Creator],
      creation_date: @pdf.info[:CreationDate],
      modification_date: @pdf.info[:ModDate],
      has_forms: has_forms?,
      has_images: has_images?,
      encrypted: @pdf.encrypted?
    }
  end

  private

  def load_pdf
    @pdf = PDF::Reader.new(@file_path)
    @page_count = @pdf.pages.length
    extract_metadata
  rescue StandardError => e
    raise "Failed to open PDF file: #{e.message}"
  end

  def extract_metadata
    info = @pdf.info || {}

    @metadata = {
      title: clean_metadata_value(info[:Title]),
      author: clean_metadata_value(info[:Author]),
      subject: clean_metadata_value(info[:Subject]),
      keywords: clean_metadata_value(info[:Keywords]),
      creator: clean_metadata_value(info[:Creator]),
      producer: clean_metadata_value(info[:Producer]),
      creation_date: format_date(info[:CreationDate]),
      modification_date: format_date(info[:ModDate]),
      page_count: @pdf.pages.length,
      pdf_version: @pdf.pdf_version
    }
  end

  def clean_metadata_value(value)
    return nil if value.nil?

    value = value.to_s.strip
    value.empty? ? nil : value
  end

  def format_date(date)
    return nil if date.nil?

    begin
      if date.is_a?(String) && date.start_with?('D:')
        # PDF date format: D:YYYYMMDDHHmmSSOHH'mm'
        date_str = date[2..-1]
        year = date_str[0..3]
        month = date_str[4..5]
        day = date_str[6..7]
        hour = date_str[8..9] || '00'
        min = date_str[10..11] || '00'
        sec = date_str[12..13] || '00'

        Time.new(year, month, day, hour, min, sec).strftime('%Y-%m-%d %H:%M:%S')
      elsif date.respond_to?(:strftime)
        date.strftime('%Y-%m-%d %H:%M:%S')
      else
        date.to_s
      end
    rescue StandardError
      date.to_s
    end
  end

  def extract_page_content(page_num)
    content = []
    page = @pdf.pages[page_num - 1]

    begin
      text = page.text.to_s

      if text && !text.strip.empty?
        # Process text content
        processed_text = process_text_content(text)
        content.concat(processed_text)
        @total_text_blocks += 1
      end

      # Extract images if requested
      if @options[:extract_images]
        images = extract_images_from_page(page, page_num)
        content.concat(images) if images && !images.empty?
      end

      # Extract tables if detected
      if @options[:extract_tables]
        tables = detect_and_extract_tables(text)
        content.concat(tables) if tables && !tables.empty?
      end
    rescue StandardError => e
      content << "*Error extracting content from this page: #{e.message}*"
      puts "  ✗ Error on page #{page_num}: #{e.message}".yellow if @options[:verbose]
    end

    content
  end

  def process_text_content(text)
    lines = []

    # Split text into paragraphs
    paragraphs = text.split(/\n\n+/)

    paragraphs.each do |paragraph|
      paragraph = paragraph.strip
      next if paragraph.empty?

      # Detect and format headers (lines in all caps or starting with numbers)
      if paragraph.match?(/^[A-Z\s]+$/) && paragraph.length < 100
        # Likely a header
        lines << "### #{paragraph.strip}"
        lines << ''
      elsif paragraph.match?(/^\d+\.?\s+[A-Z]/) && paragraph.length < 100
        # Numbered header
        lines << "### #{paragraph.strip}"
        lines << ''
      elsif paragraph.match?(/^[*\-•]\s+/)
        # Bullet points
        formatted = format_bullet_points(paragraph)
        lines.concat(formatted)
        lines << ''
      elsif paragraph.match?(/^\d+\.\s+/)
        # Numbered list
        formatted = format_numbered_list(paragraph)
        lines.concat(formatted)
        lines << ''
      else
        # Regular paragraph
        # Clean up excessive whitespace
        cleaned = paragraph.gsub(/\s+/, ' ').strip

        # Handle potential line breaks within paragraphs
        cleaned = cleaned.gsub(/([a-z])-\s+([a-z])/, '\1\2') # Rejoin hyphenated words

        lines << cleaned
        lines << ''
      end
    end

    lines
  end

  def format_bullet_points(text)
    lines = []
    points = text.split(/[\n\r]+/)

    points.each do |point|
      point = point.strip
      # Convert various bullet styles to markdown
      point = point.gsub(/^[*•-]\s*/, '- ')
      lines << point if !point.empty? && point != '-'
    end

    lines
  end

  def format_numbered_list(text)
    lines = []
    items = text.split(/[\n\r]+/)

    items.each_with_index do |item, index|
      item = item.strip
      # Ensure proper markdown numbered list format
      item = item.gsub(/^\d+\.?\s*/, "#{index + 1}. ")
      lines << item unless item.empty?
    end

    lines
  end

  def detect_and_extract_tables(text)
    tables = []

    # Simple table detection based on consistent spacing or tab patterns
    lines = text.split("\n")
    potential_table = []
    in_table = false

    lines.each do |line|
      # Detect lines with multiple columns (tabs or multiple spaces)
      if line.match?(/\t/) || line.match?(/\s{2,}/)
        cols = line.split(/\t+|\s{2,}/).map(&:strip).reject(&:empty?)
        if cols.length > 1
          potential_table << cols
          in_table = true
        elsif in_table && potential_table.length > 1
          # End of table, format it
          tables.concat(format_markdown_table(potential_table))
          tables << ''
          potential_table = []
          in_table = false
        end
      elsif in_table && potential_table.length > 1
        # End of table
        tables.concat(format_markdown_table(potential_table))
        tables << ''
        potential_table = []
        in_table = false
      end
    end

    # Handle last table if exists
    tables.concat(format_markdown_table(potential_table)) if potential_table.length > 1

    tables
  end

  def format_markdown_table(rows)
    return [] if rows.empty?

    markdown = []

    # Determine column count
    max_cols = rows.map(&:length).max

    # Normalize all rows to have same number of columns
    rows = rows.map do |row|
      row + Array.new([0, max_cols - row.length].max, '')
    end

    # Calculate column widths
    col_widths = (0...max_cols).map do |i|
      rows.map { |row| row[i].to_s.length }.max || 0
    end

    # Create header (first row)
    if rows.length > 0
      header_row = rows[0].map.with_index do |cell, i|
        cell.to_s.ljust(col_widths[i])
      end
      markdown << "| #{header_row.join(' | ')} |"

      # Create separator
      separator = col_widths.map { |width| '-' * [width, 3].max }
      markdown << "| #{separator.join(' | ')} |"

      # Add data rows
      rows[1..-1].each do |row|
        formatted_row = row.map.with_index do |cell, i|
          cell.to_s.ljust(col_widths[i])
        end
        markdown << "| #{formatted_row.join(' | ')} |"
      end
    end

    markdown
  end

  def extract_images_from_page(_page, page_num)
    images = []

    begin
      # This is a placeholder for image extraction
      # Actual implementation would require additional processing
      # using tools like pdfimages or analyzing the PDF structure

      if @options[:extract_images] == 'embed'
        # Embed images as base64 in markdown
        # images << "![Image from page #{page_num}](data:image/png;base64,...)"
      elsif @options[:extract_images] == 'separate'
        # Save images to separate files
        # image_file = "images/page_#{page_num}_image_#{img_num}.png"
        # images << "![Image](#{image_file})"
      end

      @images_extracted += images.length
    rescue StandardError => e
      puts "  ⚠ Could not extract images from page #{page_num}: #{e.message}".yellow if @options[:verbose]
    end

    images
  end

  def has_forms?
    # Check if PDF has form fields

    @pdf.objects.any? { |obj| obj.is_a?(Hash) && obj[:Type] == :AcroForm }
  rescue StandardError
    false
  end

  def has_images?
    # Check if PDF contains images

    @pdf.pages.any? do |page|
      page.raw_content.to_s.include?('/Image') ||
        page.raw_content.to_s.include?('/XObject')
    end
  rescue StandardError
    false
  end
end
