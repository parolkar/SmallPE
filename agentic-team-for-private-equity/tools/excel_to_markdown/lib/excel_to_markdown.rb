require 'roo'

class ExcelToMarkdown
  attr_reader :sheet_count, :total_rows

  def initialize(file_path, options = {})
    @file_path = file_path
    @options = options
    @sheet_count = 0
    @total_rows = 0
    load_spreadsheet
  end

  def convert_to_markdown(output_file)
    markdown_content = []

    # Add file header
    markdown_content << '# Excel to Markdown Conversion'
    markdown_content << ''
    markdown_content << "**Source File:** `#{File.basename(@file_path)}`"
    markdown_content << "**Converted:** #{Time.now.strftime('%Y-%m-%d %H:%M:%S')}"
    markdown_content << ''
    markdown_content << '---'
    markdown_content << ''

    sheets_to_process = if @options[:sheet]
                          [@options[:sheet]]
                        else
                          @spreadsheet.sheets
                        end

    sheets_to_process.each_with_index do |sheet_name, _index|
      @spreadsheet.sheet(sheet_name)

      # Add sheet header
      markdown_content << "## Sheet: #{sheet_name}"
      markdown_content << ''

      # Get sheet data
      sheet_data = extract_sheet_data(sheet_name)

      if sheet_data.empty?
        markdown_content << '*This sheet is empty.*'
        markdown_content << ''
      else
        # Convert to markdown table
        markdown_table = create_markdown_table(sheet_data)
        markdown_content.concat(markdown_table)
      end

      markdown_content << ''
      markdown_content << '---'
      markdown_content << ''

      @sheet_count += 1

      puts "  ✓ Processed sheet: #{sheet_name}".green if @options[:verbose]
    rescue StandardError => e
      puts "  ✗ Error processing sheet '#{sheet_name}': #{e.message}".yellow if @options[:verbose]
      markdown_content << "**Error:** Could not process sheet '#{sheet_name}'"
      markdown_content << ''
    end

    # Add footer
    markdown_content << ''
    markdown_content << '---'
    markdown_content << ''
    markdown_content << '*Generated by excel2md tool and SmallPE Agents at https://smallpe.com *'

    # Write to file
    File.write(output_file, markdown_content.join("\n"))
  end

  def file_info
    info = {
      file: @file_path,
      sheets: []
    }

    @spreadsheet.sheets.each do |sheet_name|
      @spreadsheet.sheet(sheet_name)
      sheet_info = {
        name: sheet_name,
        rows: @spreadsheet.last_row || 0,
        columns: @spreadsheet.last_column || 0
      }
      info[:sheets] << sheet_info
    end

    info
  end

  private

  def load_spreadsheet
    @spreadsheet = Roo::Spreadsheet.open(@file_path)
  rescue StandardError => e
    raise "Failed to open Excel file: #{e.message}"
  end

  def extract_sheet_data(sheet_name)
    @spreadsheet.sheet(sheet_name)

    return [] if @spreadsheet.last_row.nil? || @spreadsheet.last_row == 0

    data = []
    (1..@spreadsheet.last_row).each do |row_num|
      row_data = []
      (1..@spreadsheet.last_column).each do |col_num|
        cell_value = @spreadsheet.cell(row_num, col_num)
        row_data << format_cell_value(cell_value)
      end
      data << row_data
      @total_rows += 1
    end

    data
  end

  def format_cell_value(value)
    return '' if value.nil?

    # Handle different data types
    case value
    when DateTime, Date, Time
      value.strftime('%Y-%m-%d %H:%M:%S')
    when Float
      # Check if it's actually an integer
      if value == value.to_i
        value.to_i.to_s
      else
        # Format with reasonable precision
        formatted = '%.6f' % value
        # Remove trailing zeros
        formatted.sub(/\.?0+$/, '')
      end
    when String
      # Escape pipe characters for markdown tables
      value.gsub('|', '\\|').gsub("\n", ' ')
    else
      value.to_s.gsub('|', '\\|')
    end
  end

  def create_markdown_table(data)
    return [] if data.empty?

    markdown_lines = []

    # Calculate column widths for better formatting
    col_widths = calculate_column_widths(data)

    # Create header (first row)
    if data.length > 0
      header_row = data[0]
      markdown_lines << create_table_row(header_row, col_widths)

      # Create separator
      separator = col_widths.map { |width| '-' * [width, 3].max }
      markdown_lines << "| #{separator.join(' | ')} |"

      # Add data rows
      data[1..-1].each do |row|
        markdown_lines << create_table_row(row, col_widths)
      end
    end

    markdown_lines
  end

  def calculate_column_widths(data)
    return [] if data.empty?

    max_widths = Array.new(data[0].length, 0)

    data.each do |row|
      row.each_with_index do |cell, index|
        cell_length = cell.to_s.length
        max_widths[index] = cell_length if cell_length > max_widths[index]
      end
    end

    # Cap maximum width for readability
    max_widths.map { |width| [width, 50].min }
  end

  def create_table_row(row, col_widths)
    formatted_cells = []
    row.each_with_index do |cell, index|
      width = col_widths[index] || 0
      formatted_cells << cell.to_s.ljust(width)
    end
    "| #{formatted_cells.join(' | ')} |"
  end
end
